// MakeBotKey.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
using std::cout;

#include <Windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <iphlpapi.h>
#pragma comment(lib, "IPHLPAPI.lib")

#include <wincrypt.h>
#pragma comment(lib, "crypt32.lib")


#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

#define BUFSIZE 1024
#define SHA256LEN  64
#define SHA256_ASCII_LEN SHA256LEN * 2 + 1

#if _MSC_VER < 1900
#define snprintf _snprintf
#endif

#include <algorithm>
#define UPPERCASE(str) for(int i=0;str[i]!=0;i++) \
						if (str[i] <= 'z' && str[i] >= 'a') \
						str[i] -= 32;
DWORD make_bot_key(BYTE *buffer, DWORD buffer_size, char bot_id[SHA256_ASCII_LEN])
{
	DWORD dwStatus = 0;
	BOOL bResult = FALSE;
	HCRYPTPROV hProv = 0;
	HCRYPTHASH hHash = 0;
	BYTE rgbHash[SHA256LEN] = { 0 };
	DWORD cbHash = 0;

	wchar_t info[] = L"Microsoft Enhanced RSA and AES Cryptographic Provider";
	if (!CryptAcquireContextW(&hProv, NULL, info, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
		dwStatus = GetLastError();
		CryptReleaseContext(hProv, 0);
		return dwStatus;
	}

	if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
		dwStatus = GetLastError();
		CryptReleaseContext(hProv, 0);
		return dwStatus;
	}

	if (!CryptHashData(hHash, buffer, buffer_size, 0)) {
		dwStatus = GetLastError();
		CryptReleaseContext(hProv, 0);
		CryptDestroyHash(hHash);
		return dwStatus;
	}
	cbHash = SHA256LEN;
	if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0)) {
		for (DWORD i = 0; i < cbHash; i++) {
			snprintf(bot_id, SHA256_ASCII_LEN, "%02X", rgbHash[i]);
			bot_id += 2;
		}
	}
	else {
		dwStatus = GetLastError();
	}
	CryptReleaseContext(hProv, 0);
	return dwStatus;
}


unsigned char HexChar(char c)
{
	if ('0' <= c && c <= '9') return (unsigned char)(c - '0');
	if ('A' <= c && c <= 'F') return (unsigned char)(c - 'A' + 10);
	if ('a' <= c && c <= 'f') return (unsigned char)(c - 'a' + 10);
	return 0xFF;
}

int HexToBin(const char* s, unsigned char * buff, int length)
{
	int result;
	if (!s || !buff || length <= 0) return -1;

	for (result = 0; *s; ++result)
	{
		unsigned char msn = HexChar(*s++);
		if (msn == 0xFF) return -1;
		unsigned char lsn = HexChar(*s++);
		if (lsn == 0xFF) return -1;
		unsigned char bin = (msn << 4) + lsn;

		if (length-- <= 0) return -1;
		*buff++ = bin;
	}
	return result;
}


#define HASH_INPUT_LENGTH 0x194
int main(int argc, char **argv)
{
	PIP_ADAPTER_INFO pAdapterInfo = NULL;
	PIP_ADAPTER_INFO pAdapter = NULL;
	DWORD dwRetVal = 0;
	ULONG ulOutBufLen = sizeof(IP_ADAPTER_INFO);
	char adapterName[HASH_INPUT_LENGTH];
	ZeroMemory(adapterName, HASH_INPUT_LENGTH);
	char bot_id[SHA256_ASCII_LEN] = { 0 };
	if (argc < 3) {

		pAdapterInfo = (IP_ADAPTER_INFO *)MALLOC(sizeof(IP_ADAPTER_INFO));
		if (pAdapterInfo == NULL) {
			fprintf(stderr, "Error allocating memory needed to call GetAdaptersinfo\n");
			return 1;
		}
		ZeroMemory(pAdapterInfo, sizeof(IP_ADAPTER_INFO));

		if (GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW) {
			FREE(pAdapterInfo);
			pAdapterInfo = (IP_ADAPTER_INFO *)MALLOC(ulOutBufLen);
			if (pAdapterInfo == NULL) {
				fprintf(stderr, "Error allocating memory needed to call GetAdaptersinfo\n");
				return 1;
			}
			ZeroMemory(pAdapterInfo, sizeof(IP_ADAPTER_INFO));
		}

		if ((dwRetVal = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen)) != NO_ERROR) {
			fprintf(stderr, "Warning: GetAdaptersInfo failed with error: %d.\nContinuing with empty buffer...\n", dwRetVal);
			// TrickBot will continue generating even if getting adapter info has failed...
		}


		//Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\5
		//memcpy_s(adapterName, 0x194,"%s", pAdapterInfo->AdapterName);
		//sprintf((char *)&adapterName+260,HASH_INPUT_LENGTH-260,)
		//adapterName = pAdapterInfo->AdapterName;
	}
	else {
		pAdapterInfo = (PIP_ADAPTER_INFO)malloc(sizeof(IP_ADAPTER_INFO));
		ZeroMemory(pAdapterInfo, sizeof(IP_ADAPTER_INFO));
		//		u_int index = 0;

		cout << "Using AdapterName: '" << argv[1] << "'\r\n";
		snprintf(pAdapterInfo->AdapterName, strnlen_s(argv[1], MAX_ADAPTER_NAME_LENGTH) + 1, "%s", argv[1]);
		cout << "Using Description: '" << argv[2] << "'\r\n";
		snprintf(pAdapterInfo->Description, strnlen_s(argv[2], MAX_ADAPTER_DESCRIPTION_LENGTH) + 1, "%s", argv[2]);

		pAdapterInfo->AddressLength = 6;

		//		char adapterAddress[7] = { 0,0,0,0,0,0,0 };
		UPPERCASE(argv[3]);
		HexToBin(argv[3], pAdapterInfo->Address, 6);
		pAdapterInfo->Address[6] = 0;




		//adapterName = argv[1];


	}
	cout << "Retrieved AdapterName: '" << pAdapterInfo->AdapterName << "'\r\n";
	cout << "Retrieved Description'" << pAdapterInfo->Description << "'\r\n";
	cout << "Retrieved Address(" << pAdapterInfo->AddressLength << ") '" << std::hex << pAdapterInfo->Address << std::dec << "'\r\n";
	memcpy_s(adapterName, HASH_INPUT_LENGTH, pAdapterInfo->AdapterName, HASH_INPUT_LENGTH);

	if ((dwRetVal = make_bot_key((BYTE*)&adapterName, 0x194, bot_id)) == NO_ERROR) {
		printf("botkey=%s\n", bot_id);
	}
	else {
		cout << "Error whie making bot key: " << dwRetVal << "\r\n";
	}
	if (pAdapterInfo)
		FREE(pAdapterInfo);
	system("pause");
	return dwRetVal;

}
